/*
 * TODO: imglib2 header
 */

/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package net.imglib2.blk.downsample;

import net.imglib2.type.NativeType;
import net.imglib2.util.Cast;

class TypeConversionGenerated
{

    /*
     * Methods to convert each pixel type (i8, u8, i16, u16, i32, u32, i64, f32, f64)
     * to the corresponding primitive type used for computation.
     *
     * i8, u8, i16, u16, i32 are all converted to int, because java
     * computes in int for byte, short, and int operands.
     *
     * u32, i64 are converted to long, because that is the primitive type that
     * can represent all values of the pixel type.
     *
     * f32 is converted to float
     *
     * f64 is converted to double
     */
	static int from_i8( byte value ) { return value; }
	static int from_u8( byte value ) { return value & 0xff; }
	static int from_i16( short value ) { return value; }
	static int from_u16( short value ) { return value & 0xffff; }
	static int from_i32( int value ) { return value; }
	static long from_u32( int value ) { return value & 0xffffffffL; }
	static long from_i64( long value ) { return value; }
	static float from_f32( float value ) { return value; }
	static double from_f64( double value ) { return value; }

    static byte to_i8( int value ) { return ( byte ) value; }
    static byte to_i8_clamp_max( int value ) { return to_i8( Math.min( 0x7f, value ) ); }
    static byte to_i8_clamp( int value ) { return to_i8( Math.min( 0x7f, Math.max( -0x80, value ) ) ); }
    static byte to_u8( int value ) { return ( byte ) value; }
    static byte to_u8_clamp_max( int value ) { return to_u8( Math.min( 0xff, value ) ); }
    static byte to_u8_clamp( int value ) { return to_u8( Math.min( 0xff, Math.max( 0, value ) ) ); }
    static short to_i16( int value ) { return ( short ) value; }
    static short to_i16_clamp_max( int value ) { return to_i16( Math.min( 0x7fff, value ) ); }
    static short to_i16_clamp( int value ) { return to_i16( Math.min( 0x7fff, Math.max( -0x8000, value ) ) ); }
    static short to_u16( int value ) { return ( short ) value; }
    static short to_u16_clamp_max( int value ) { return to_u16( Math.min( 0xffff, value ) ); }
    static short to_u16_clamp( int value ) { return to_u16( Math.min( 0xffff, Math.max( 0, value ) ) ); }
    static int to_i32( int value ) { return value; }
    static int to_i32_clamp_max( int value ) { return to_i32( value ); }
    static int to_i32_clamp( int value ) { return to_i32( value ); }
    static int to_u32( int value ) { return value; }
    static int to_u32_clamp_max( int value ) { return to_u32( Math.min( 0xffff_ffffL, value ) ); }
    static int to_u32_clamp( int value ) { return to_u32( Math.min( 0xffff_ffffL, Math.max( 0L, value ) ) ); }
    static long to_i64( int value ) { return value; }
    static long to_i64_clamp_max( int value ) { return to_i64( value ); }
    static long to_i64_clamp( int value ) { return to_i64( value ); }
    static float to_f32( int value ) { return value; }
    static float to_f32_clamp_max( int value ) { return to_f32( value ); }
    static float to_f32_clamp( int value ) { return to_f32( value ); }
    static double to_f64( int value ) { return value; }
    static double to_f64_clamp_max( int value ) { return to_f64( value ); }
    static double to_f64_clamp( int value ) { return to_f64( value ); }

    static byte to_i8( long value ) { return ( byte ) value; }
    static byte to_i8_clamp_max( long value ) { return to_i8( Math.min( 0x7f, value ) ); }
    static byte to_i8_clamp( long value ) { return to_i8( Math.min( 0x7f, Math.max( -0x80, value ) ) ); }
    static byte to_u8( long value ) { return ( byte ) value; }
    static byte to_u8_clamp_max( long value ) { return to_u8( Math.min( 0xff, value ) ); }
    static byte to_u8_clamp( long value ) { return to_u8( Math.min( 0xff, Math.max( 0, value ) ) ); }
    static short to_i16( long value ) { return ( short ) value; }
    static short to_i16_clamp_max( long value ) { return to_i16( Math.min( 0x7fff, value ) ); }
    static short to_i16_clamp( long value ) { return to_i16( Math.min( 0x7fff, Math.max( -0x8000, value ) ) ); }
    static short to_u16( long value ) { return ( short ) value; }
    static short to_u16_clamp_max( long value ) { return to_u16( Math.min( 0xffff, value ) ); }
    static short to_u16_clamp( long value ) { return to_u16( Math.min( 0xffff, Math.max( 0, value ) ) ); }
    static int to_i32( long value ) { return ( int ) value; }
    static int to_i32_clamp_max( long value ) { return to_i32( Math.min( 0x7fff_ffff, value ) ); }
    static int to_i32_clamp( long value ) { return to_i32( Math.min( 0x7fff_ffff, Math.max( -0x8000_0000, value ) ) ); }
    static int to_u32( long value ) { return ( int ) value; }
    static int to_u32_clamp_max( long value ) { return to_u32( Math.min( 0xffff_ffffL, value ) ); }
    static int to_u32_clamp( long value ) { return to_u32( Math.min( 0xffff_ffffL, Math.max( 0L, value ) ) ); }
    static long to_i64( long value ) { return value; }
    static long to_i64_clamp_max( long value ) { return to_i64( value ); }
    static long to_i64_clamp( long value ) { return to_i64( value ); }
    static float to_f32( long value ) { return ( float ) value; }
    static float to_f32_clamp_max( long value ) { return to_f32( value ); }
    static float to_f32_clamp( long value ) { return to_f32( value ); }
    static double to_f64( long value ) { return value; }
    static double to_f64_clamp_max( long value ) { return to_f64( value ); }
    static double to_f64_clamp( long value ) { return to_f64( value ); }

    static byte to_i8( float value ) { return to_i8( Math.round( value ) ); }
	static byte to_i8_clamp_max( float value ) { return to_i8_clamp_max( Math.round( value ) ); }
	static byte to_i8_clamp( float value ) { return to_i8_clamp( Math.round( value ) ); }
    static byte to_u8( float value ) { return to_u8( Math.round( value ) ); }
	static byte to_u8_clamp_max( float value ) { return to_u8_clamp_max( Math.round( value ) ); }
	static byte to_u8_clamp( float value ) { return to_u8_clamp( Math.round( value ) ); }
    static short to_i16( float value ) { return to_i16( Math.round( value ) ); }
	static short to_i16_clamp_max( float value ) { return to_i16_clamp_max( Math.round( value ) ); }
	static short to_i16_clamp( float value ) { return to_i16_clamp( Math.round( value ) ); }
    static short to_u16( float value ) { return to_u16( Math.round( value ) ); }
	static short to_u16_clamp_max( float value ) { return to_u16_clamp_max( Math.round( value ) ); }
	static short to_u16_clamp( float value ) { return to_u16_clamp( Math.round( value ) ); }
    static int to_i32( float value ) { return to_i32( Math.round( value ) ); }
	static int to_i32_clamp_max( float value ) { return to_i32_clamp_max( Math.round( value ) ); }
	static int to_i32_clamp( float value ) { return to_i32_clamp( Math.round( value ) ); }
	static int to_u32( float value ) { return to_u32( Math.round( ( double ) value ) ); }
	static int to_u32_clamp_max( float value ) { return to_u32_clamp_max( Math.round( ( double ) value ) ); }
	static int to_u32_clamp( float value ) { return to_u32_clamp( Math.round( ( double ) value ) ); }
	static long to_i64( float value ) { return to_i64( Math.round( ( double ) value ) ); }
	static long to_i64_clamp_max( float value ) { return to_i64_clamp_max( Math.round( ( double ) value ) ); }
	static long to_i64_clamp( float value ) { return to_i64_clamp( Math.round( ( double ) value ) ); }
    static float to_f32( float value ) { return to_f32( Math.round( value ) ); }
	static float to_f32_clamp_max( float value ) { return to_f32_clamp_max( Math.round( value ) ); }
	static float to_f32_clamp( float value ) { return to_f32_clamp( Math.round( value ) ); }
    static double to_f64( float value ) { return to_f64( Math.round( value ) ); }
	static double to_f64_clamp_max( float value ) { return to_f64_clamp_max( Math.round( value ) ); }
	static double to_f64_clamp( float value ) { return to_f64_clamp( Math.round( value ) ); }

    static byte to_i8( double value ) { return to_i8( Math.round( value ) ); }
	static byte to_i8_clamp_max( double value ) { return to_i8_clamp_max( Math.round( value ) ); }
	static byte to_i8_clamp( double value ) { return to_i8_clamp( Math.round( value ) ); }
    static byte to_u8( double value ) { return to_u8( Math.round( value ) ); }
	static byte to_u8_clamp_max( double value ) { return to_u8_clamp_max( Math.round( value ) ); }
	static byte to_u8_clamp( double value ) { return to_u8_clamp( Math.round( value ) ); }
    static short to_i16( double value ) { return to_i16( Math.round( value ) ); }
	static short to_i16_clamp_max( double value ) { return to_i16_clamp_max( Math.round( value ) ); }
	static short to_i16_clamp( double value ) { return to_i16_clamp( Math.round( value ) ); }
    static short to_u16( double value ) { return to_u16( Math.round( value ) ); }
	static short to_u16_clamp_max( double value ) { return to_u16_clamp_max( Math.round( value ) ); }
	static short to_u16_clamp( double value ) { return to_u16_clamp( Math.round( value ) ); }
    static int to_i32( double value ) { return to_i32( Math.round( value ) ); }
	static int to_i32_clamp_max( double value ) { return to_i32_clamp_max( Math.round( value ) ); }
	static int to_i32_clamp( double value ) { return to_i32_clamp( Math.round( value ) ); }
    static int to_u32( double value ) { return to_u32( Math.round( value ) ); }
	static int to_u32_clamp_max( double value ) { return to_u32_clamp_max( Math.round( value ) ); }
	static int to_u32_clamp( double value ) { return to_u32_clamp( Math.round( value ) ); }
    static long to_i64( double value ) { return to_i64( Math.round( value ) ); }
	static long to_i64_clamp_max( double value ) { return to_i64_clamp_max( Math.round( value ) ); }
	static long to_i64_clamp( double value ) { return to_i64_clamp( Math.round( value ) ); }
    static float to_f32( double value ) { return to_f32( Math.round( value ) ); }
	static float to_f32_clamp_max( double value ) { return to_f32_clamp_max( Math.round( value ) ); }
	static float to_f32_clamp( double value ) { return to_f32_clamp( Math.round( value ) ); }
    static double to_f64( double value ) { return to_f64( Math.round( value ) ); }
	static double to_f64_clamp_max( double value ) { return to_f64_clamp_max( Math.round( value ) ); }
	static double to_f64_clamp( double value ) { return to_f64_clamp( Math.round( value ) ); }





    @FunctionalInterface
    interface ConvertLoop< I, O >
    {
        void apply( final I src, final O dest, final int length );

        static < I, O > ConvertLoop< I, O > get( UnaryOperatorType type )
        {
            switch( type )
            {
            case I8_TO_I8:
				return Cast.unchecked( Convert_i8_to_i8.INSTANCE );
            case I8_TO_U8:
				return Cast.unchecked( Convert_i8_to_u8.INSTANCE );
            case I8_TO_I16:
				return Cast.unchecked( Convert_i8_to_i16.INSTANCE );
            case I8_TO_U16:
				return Cast.unchecked( Convert_i8_to_u16.INSTANCE );
            case I8_TO_I32:
				return Cast.unchecked( Convert_i8_to_i32.INSTANCE );
            case I8_TO_U32:
				return Cast.unchecked( Convert_i8_to_u32.INSTANCE );
            case I8_TO_I64:
				return Cast.unchecked( Convert_i8_to_i64.INSTANCE );
            case I8_TO_F32:
				return Cast.unchecked( Convert_i8_to_f32.INSTANCE );
            case I8_TO_F64:
				return Cast.unchecked( Convert_i8_to_f64.INSTANCE );
            case U8_TO_I8:
				return Cast.unchecked( Convert_u8_to_i8.INSTANCE );
            case U8_TO_U8:
				return Cast.unchecked( Convert_u8_to_u8.INSTANCE );
            case U8_TO_I16:
				return Cast.unchecked( Convert_u8_to_i16.INSTANCE );
            case U8_TO_U16:
				return Cast.unchecked( Convert_u8_to_u16.INSTANCE );
            case U8_TO_I32:
				return Cast.unchecked( Convert_u8_to_i32.INSTANCE );
            case U8_TO_U32:
				return Cast.unchecked( Convert_u8_to_u32.INSTANCE );
            case U8_TO_I64:
				return Cast.unchecked( Convert_u8_to_i64.INSTANCE );
            case U8_TO_F32:
				return Cast.unchecked( Convert_u8_to_f32.INSTANCE );
            case U8_TO_F64:
				return Cast.unchecked( Convert_u8_to_f64.INSTANCE );
            case I16_TO_I8:
				return Cast.unchecked( Convert_i16_to_i8.INSTANCE );
            case I16_TO_U8:
				return Cast.unchecked( Convert_i16_to_u8.INSTANCE );
            case I16_TO_I16:
				return Cast.unchecked( Convert_i16_to_i16.INSTANCE );
            case I16_TO_U16:
				return Cast.unchecked( Convert_i16_to_u16.INSTANCE );
            case I16_TO_I32:
				return Cast.unchecked( Convert_i16_to_i32.INSTANCE );
            case I16_TO_U32:
				return Cast.unchecked( Convert_i16_to_u32.INSTANCE );
            case I16_TO_I64:
				return Cast.unchecked( Convert_i16_to_i64.INSTANCE );
            case I16_TO_F32:
				return Cast.unchecked( Convert_i16_to_f32.INSTANCE );
            case I16_TO_F64:
				return Cast.unchecked( Convert_i16_to_f64.INSTANCE );
            case U16_TO_I8:
				return Cast.unchecked( Convert_u16_to_i8.INSTANCE );
            case U16_TO_U8:
				return Cast.unchecked( Convert_u16_to_u8.INSTANCE );
            case U16_TO_I16:
				return Cast.unchecked( Convert_u16_to_i16.INSTANCE );
            case U16_TO_U16:
				return Cast.unchecked( Convert_u16_to_u16.INSTANCE );
            case U16_TO_I32:
				return Cast.unchecked( Convert_u16_to_i32.INSTANCE );
            case U16_TO_U32:
				return Cast.unchecked( Convert_u16_to_u32.INSTANCE );
            case U16_TO_I64:
				return Cast.unchecked( Convert_u16_to_i64.INSTANCE );
            case U16_TO_F32:
				return Cast.unchecked( Convert_u16_to_f32.INSTANCE );
            case U16_TO_F64:
				return Cast.unchecked( Convert_u16_to_f64.INSTANCE );
            case I32_TO_I8:
				return Cast.unchecked( Convert_i32_to_i8.INSTANCE );
            case I32_TO_U8:
				return Cast.unchecked( Convert_i32_to_u8.INSTANCE );
            case I32_TO_I16:
				return Cast.unchecked( Convert_i32_to_i16.INSTANCE );
            case I32_TO_U16:
				return Cast.unchecked( Convert_i32_to_u16.INSTANCE );
            case I32_TO_I32:
				return Cast.unchecked( Convert_i32_to_i32.INSTANCE );
            case I32_TO_U32:
				return Cast.unchecked( Convert_i32_to_u32.INSTANCE );
            case I32_TO_I64:
				return Cast.unchecked( Convert_i32_to_i64.INSTANCE );
            case I32_TO_F32:
				return Cast.unchecked( Convert_i32_to_f32.INSTANCE );
            case I32_TO_F64:
				return Cast.unchecked( Convert_i32_to_f64.INSTANCE );
            case U32_TO_I8:
				return Cast.unchecked( Convert_u32_to_i8.INSTANCE );
            case U32_TO_U8:
				return Cast.unchecked( Convert_u32_to_u8.INSTANCE );
            case U32_TO_I16:
				return Cast.unchecked( Convert_u32_to_i16.INSTANCE );
            case U32_TO_U16:
				return Cast.unchecked( Convert_u32_to_u16.INSTANCE );
            case U32_TO_I32:
				return Cast.unchecked( Convert_u32_to_i32.INSTANCE );
            case U32_TO_U32:
				return Cast.unchecked( Convert_u32_to_u32.INSTANCE );
            case U32_TO_I64:
				return Cast.unchecked( Convert_u32_to_i64.INSTANCE );
            case U32_TO_F32:
				return Cast.unchecked( Convert_u32_to_f32.INSTANCE );
            case U32_TO_F64:
				return Cast.unchecked( Convert_u32_to_f64.INSTANCE );
            case I64_TO_I8:
				return Cast.unchecked( Convert_i64_to_i8.INSTANCE );
            case I64_TO_U8:
				return Cast.unchecked( Convert_i64_to_u8.INSTANCE );
            case I64_TO_I16:
				return Cast.unchecked( Convert_i64_to_i16.INSTANCE );
            case I64_TO_U16:
				return Cast.unchecked( Convert_i64_to_u16.INSTANCE );
            case I64_TO_I32:
				return Cast.unchecked( Convert_i64_to_i32.INSTANCE );
            case I64_TO_U32:
				return Cast.unchecked( Convert_i64_to_u32.INSTANCE );
            case I64_TO_I64:
				return Cast.unchecked( Convert_i64_to_i64.INSTANCE );
            case I64_TO_F32:
				return Cast.unchecked( Convert_i64_to_f32.INSTANCE );
            case I64_TO_F64:
				return Cast.unchecked( Convert_i64_to_f64.INSTANCE );
            case F32_TO_I8:
				return Cast.unchecked( Convert_f32_to_i8.INSTANCE );
            case F32_TO_U8:
				return Cast.unchecked( Convert_f32_to_u8.INSTANCE );
            case F32_TO_I16:
				return Cast.unchecked( Convert_f32_to_i16.INSTANCE );
            case F32_TO_U16:
				return Cast.unchecked( Convert_f32_to_u16.INSTANCE );
            case F32_TO_I32:
				return Cast.unchecked( Convert_f32_to_i32.INSTANCE );
            case F32_TO_U32:
				return Cast.unchecked( Convert_f32_to_u32.INSTANCE );
            case F32_TO_I64:
				return Cast.unchecked( Convert_f32_to_i64.INSTANCE );
            case F32_TO_F32:
				return Cast.unchecked( Convert_f32_to_f32.INSTANCE );
            case F32_TO_F64:
				return Cast.unchecked( Convert_f32_to_f64.INSTANCE );
            case F64_TO_I8:
				return Cast.unchecked( Convert_f64_to_i8.INSTANCE );
            case F64_TO_U8:
				return Cast.unchecked( Convert_f64_to_u8.INSTANCE );
            case F64_TO_I16:
				return Cast.unchecked( Convert_f64_to_i16.INSTANCE );
            case F64_TO_U16:
				return Cast.unchecked( Convert_f64_to_u16.INSTANCE );
            case F64_TO_I32:
				return Cast.unchecked( Convert_f64_to_i32.INSTANCE );
            case F64_TO_U32:
				return Cast.unchecked( Convert_f64_to_u32.INSTANCE );
            case F64_TO_I64:
				return Cast.unchecked( Convert_f64_to_i64.INSTANCE );
            case F64_TO_F32:
				return Cast.unchecked( Convert_f64_to_f32.INSTANCE );
            case F64_TO_F64:
				return Cast.unchecked( Convert_f64_to_f64.INSTANCE );
            default:
                throw new IllegalArgumentException();
            }
        }
    }


	static class Convert_i8_to_i8 implements ConvertLoop< byte[], byte[] >
	{
		static final Convert_i8_to_i8 INSTANCE = new Convert_i8_to_i8();

		@Override
		public void apply( final byte[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_u8 implements ConvertLoop< byte[], byte[] >
	{
		static final Convert_i8_to_u8 INSTANCE = new Convert_i8_to_u8();

		@Override
		public void apply( final byte[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_i16 implements ConvertLoop< byte[], short[] >
	{
		static final Convert_i8_to_i16 INSTANCE = new Convert_i8_to_i16();

		@Override
		public void apply( final byte[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_u16 implements ConvertLoop< byte[], short[] >
	{
		static final Convert_i8_to_u16 INSTANCE = new Convert_i8_to_u16();

		@Override
		public void apply( final byte[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_i32 implements ConvertLoop< byte[], int[] >
	{
		static final Convert_i8_to_i32 INSTANCE = new Convert_i8_to_i32();

		@Override
		public void apply( final byte[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_u32 implements ConvertLoop< byte[], int[] >
	{
		static final Convert_i8_to_u32 INSTANCE = new Convert_i8_to_u32();

		@Override
		public void apply( final byte[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_i64 implements ConvertLoop< byte[], long[] >
	{
		static final Convert_i8_to_i64 INSTANCE = new Convert_i8_to_i64();

		@Override
		public void apply( final byte[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_f32 implements ConvertLoop< byte[], float[] >
	{
		static final Convert_i8_to_f32 INSTANCE = new Convert_i8_to_f32();

		@Override
		public void apply( final byte[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_i8( src[ i ] ) );
		}
	}

	static class Convert_i8_to_f64 implements ConvertLoop< byte[], double[] >
	{
		static final Convert_i8_to_f64 INSTANCE = new Convert_i8_to_f64();

		@Override
		public void apply( final byte[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_i8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_i8 implements ConvertLoop< byte[], byte[] >
	{
		static final Convert_u8_to_i8 INSTANCE = new Convert_u8_to_i8();

		@Override
		public void apply( final byte[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_u8 implements ConvertLoop< byte[], byte[] >
	{
		static final Convert_u8_to_u8 INSTANCE = new Convert_u8_to_u8();

		@Override
		public void apply( final byte[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_i16 implements ConvertLoop< byte[], short[] >
	{
		static final Convert_u8_to_i16 INSTANCE = new Convert_u8_to_i16();

		@Override
		public void apply( final byte[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_u16 implements ConvertLoop< byte[], short[] >
	{
		static final Convert_u8_to_u16 INSTANCE = new Convert_u8_to_u16();

		@Override
		public void apply( final byte[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_i32 implements ConvertLoop< byte[], int[] >
	{
		static final Convert_u8_to_i32 INSTANCE = new Convert_u8_to_i32();

		@Override
		public void apply( final byte[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_u32 implements ConvertLoop< byte[], int[] >
	{
		static final Convert_u8_to_u32 INSTANCE = new Convert_u8_to_u32();

		@Override
		public void apply( final byte[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_i64 implements ConvertLoop< byte[], long[] >
	{
		static final Convert_u8_to_i64 INSTANCE = new Convert_u8_to_i64();

		@Override
		public void apply( final byte[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_f32 implements ConvertLoop< byte[], float[] >
	{
		static final Convert_u8_to_f32 INSTANCE = new Convert_u8_to_f32();

		@Override
		public void apply( final byte[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_u8( src[ i ] ) );
		}
	}

	static class Convert_u8_to_f64 implements ConvertLoop< byte[], double[] >
	{
		static final Convert_u8_to_f64 INSTANCE = new Convert_u8_to_f64();

		@Override
		public void apply( final byte[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_u8( src[ i ] ) );
		}
	}

	static class Convert_i16_to_i8 implements ConvertLoop< short[], byte[] >
	{
		static final Convert_i16_to_i8 INSTANCE = new Convert_i16_to_i8();

		@Override
		public void apply( final short[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_u8 implements ConvertLoop< short[], byte[] >
	{
		static final Convert_i16_to_u8 INSTANCE = new Convert_i16_to_u8();

		@Override
		public void apply( final short[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_i16 implements ConvertLoop< short[], short[] >
	{
		static final Convert_i16_to_i16 INSTANCE = new Convert_i16_to_i16();

		@Override
		public void apply( final short[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_u16 implements ConvertLoop< short[], short[] >
	{
		static final Convert_i16_to_u16 INSTANCE = new Convert_i16_to_u16();

		@Override
		public void apply( final short[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_i32 implements ConvertLoop< short[], int[] >
	{
		static final Convert_i16_to_i32 INSTANCE = new Convert_i16_to_i32();

		@Override
		public void apply( final short[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_u32 implements ConvertLoop< short[], int[] >
	{
		static final Convert_i16_to_u32 INSTANCE = new Convert_i16_to_u32();

		@Override
		public void apply( final short[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_i64 implements ConvertLoop< short[], long[] >
	{
		static final Convert_i16_to_i64 INSTANCE = new Convert_i16_to_i64();

		@Override
		public void apply( final short[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_f32 implements ConvertLoop< short[], float[] >
	{
		static final Convert_i16_to_f32 INSTANCE = new Convert_i16_to_f32();

		@Override
		public void apply( final short[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_i16( src[ i ] ) );
		}
	}

	static class Convert_i16_to_f64 implements ConvertLoop< short[], double[] >
	{
		static final Convert_i16_to_f64 INSTANCE = new Convert_i16_to_f64();

		@Override
		public void apply( final short[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_i16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_i8 implements ConvertLoop< short[], byte[] >
	{
		static final Convert_u16_to_i8 INSTANCE = new Convert_u16_to_i8();

		@Override
		public void apply( final short[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_u8 implements ConvertLoop< short[], byte[] >
	{
		static final Convert_u16_to_u8 INSTANCE = new Convert_u16_to_u8();

		@Override
		public void apply( final short[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_i16 implements ConvertLoop< short[], short[] >
	{
		static final Convert_u16_to_i16 INSTANCE = new Convert_u16_to_i16();

		@Override
		public void apply( final short[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_u16 implements ConvertLoop< short[], short[] >
	{
		static final Convert_u16_to_u16 INSTANCE = new Convert_u16_to_u16();

		@Override
		public void apply( final short[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_i32 implements ConvertLoop< short[], int[] >
	{
		static final Convert_u16_to_i32 INSTANCE = new Convert_u16_to_i32();

		@Override
		public void apply( final short[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_u32 implements ConvertLoop< short[], int[] >
	{
		static final Convert_u16_to_u32 INSTANCE = new Convert_u16_to_u32();

		@Override
		public void apply( final short[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_i64 implements ConvertLoop< short[], long[] >
	{
		static final Convert_u16_to_i64 INSTANCE = new Convert_u16_to_i64();

		@Override
		public void apply( final short[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_f32 implements ConvertLoop< short[], float[] >
	{
		static final Convert_u16_to_f32 INSTANCE = new Convert_u16_to_f32();

		@Override
		public void apply( final short[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_u16( src[ i ] ) );
		}
	}

	static class Convert_u16_to_f64 implements ConvertLoop< short[], double[] >
	{
		static final Convert_u16_to_f64 INSTANCE = new Convert_u16_to_f64();

		@Override
		public void apply( final short[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_u16( src[ i ] ) );
		}
	}

	static class Convert_i32_to_i8 implements ConvertLoop< int[], byte[] >
	{
		static final Convert_i32_to_i8 INSTANCE = new Convert_i32_to_i8();

		@Override
		public void apply( final int[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_u8 implements ConvertLoop< int[], byte[] >
	{
		static final Convert_i32_to_u8 INSTANCE = new Convert_i32_to_u8();

		@Override
		public void apply( final int[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_i16 implements ConvertLoop< int[], short[] >
	{
		static final Convert_i32_to_i16 INSTANCE = new Convert_i32_to_i16();

		@Override
		public void apply( final int[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_u16 implements ConvertLoop< int[], short[] >
	{
		static final Convert_i32_to_u16 INSTANCE = new Convert_i32_to_u16();

		@Override
		public void apply( final int[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_i32 implements ConvertLoop< int[], int[] >
	{
		static final Convert_i32_to_i32 INSTANCE = new Convert_i32_to_i32();

		@Override
		public void apply( final int[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_u32 implements ConvertLoop< int[], int[] >
	{
		static final Convert_i32_to_u32 INSTANCE = new Convert_i32_to_u32();

		@Override
		public void apply( final int[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_i64 implements ConvertLoop< int[], long[] >
	{
		static final Convert_i32_to_i64 INSTANCE = new Convert_i32_to_i64();

		@Override
		public void apply( final int[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_f32 implements ConvertLoop< int[], float[] >
	{
		static final Convert_i32_to_f32 INSTANCE = new Convert_i32_to_f32();

		@Override
		public void apply( final int[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_i32( src[ i ] ) );
		}
	}

	static class Convert_i32_to_f64 implements ConvertLoop< int[], double[] >
	{
		static final Convert_i32_to_f64 INSTANCE = new Convert_i32_to_f64();

		@Override
		public void apply( final int[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_i32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_i8 implements ConvertLoop< int[], byte[] >
	{
		static final Convert_u32_to_i8 INSTANCE = new Convert_u32_to_i8();

		@Override
		public void apply( final int[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_u8 implements ConvertLoop< int[], byte[] >
	{
		static final Convert_u32_to_u8 INSTANCE = new Convert_u32_to_u8();

		@Override
		public void apply( final int[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_i16 implements ConvertLoop< int[], short[] >
	{
		static final Convert_u32_to_i16 INSTANCE = new Convert_u32_to_i16();

		@Override
		public void apply( final int[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_u16 implements ConvertLoop< int[], short[] >
	{
		static final Convert_u32_to_u16 INSTANCE = new Convert_u32_to_u16();

		@Override
		public void apply( final int[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_i32 implements ConvertLoop< int[], int[] >
	{
		static final Convert_u32_to_i32 INSTANCE = new Convert_u32_to_i32();

		@Override
		public void apply( final int[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_u32 implements ConvertLoop< int[], int[] >
	{
		static final Convert_u32_to_u32 INSTANCE = new Convert_u32_to_u32();

		@Override
		public void apply( final int[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_i64 implements ConvertLoop< int[], long[] >
	{
		static final Convert_u32_to_i64 INSTANCE = new Convert_u32_to_i64();

		@Override
		public void apply( final int[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_f32 implements ConvertLoop< int[], float[] >
	{
		static final Convert_u32_to_f32 INSTANCE = new Convert_u32_to_f32();

		@Override
		public void apply( final int[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_u32( src[ i ] ) );
		}
	}

	static class Convert_u32_to_f64 implements ConvertLoop< int[], double[] >
	{
		static final Convert_u32_to_f64 INSTANCE = new Convert_u32_to_f64();

		@Override
		public void apply( final int[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_u32( src[ i ] ) );
		}
	}

	static class Convert_i64_to_i8 implements ConvertLoop< long[], byte[] >
	{
		static final Convert_i64_to_i8 INSTANCE = new Convert_i64_to_i8();

		@Override
		public void apply( final long[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_u8 implements ConvertLoop< long[], byte[] >
	{
		static final Convert_i64_to_u8 INSTANCE = new Convert_i64_to_u8();

		@Override
		public void apply( final long[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_i16 implements ConvertLoop< long[], short[] >
	{
		static final Convert_i64_to_i16 INSTANCE = new Convert_i64_to_i16();

		@Override
		public void apply( final long[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_u16 implements ConvertLoop< long[], short[] >
	{
		static final Convert_i64_to_u16 INSTANCE = new Convert_i64_to_u16();

		@Override
		public void apply( final long[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_i32 implements ConvertLoop< long[], int[] >
	{
		static final Convert_i64_to_i32 INSTANCE = new Convert_i64_to_i32();

		@Override
		public void apply( final long[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_u32 implements ConvertLoop< long[], int[] >
	{
		static final Convert_i64_to_u32 INSTANCE = new Convert_i64_to_u32();

		@Override
		public void apply( final long[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_i64 implements ConvertLoop< long[], long[] >
	{
		static final Convert_i64_to_i64 INSTANCE = new Convert_i64_to_i64();

		@Override
		public void apply( final long[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_f32 implements ConvertLoop< long[], float[] >
	{
		static final Convert_i64_to_f32 INSTANCE = new Convert_i64_to_f32();

		@Override
		public void apply( final long[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_i64( src[ i ] ) );
		}
	}

	static class Convert_i64_to_f64 implements ConvertLoop< long[], double[] >
	{
		static final Convert_i64_to_f64 INSTANCE = new Convert_i64_to_f64();

		@Override
		public void apply( final long[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_i64( src[ i ] ) );
		}
	}

	static class Convert_f32_to_i8 implements ConvertLoop< float[], byte[] >
	{
		static final Convert_f32_to_i8 INSTANCE = new Convert_f32_to_i8();

		@Override
		public void apply( final float[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_u8 implements ConvertLoop< float[], byte[] >
	{
		static final Convert_f32_to_u8 INSTANCE = new Convert_f32_to_u8();

		@Override
		public void apply( final float[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_i16 implements ConvertLoop< float[], short[] >
	{
		static final Convert_f32_to_i16 INSTANCE = new Convert_f32_to_i16();

		@Override
		public void apply( final float[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_u16 implements ConvertLoop< float[], short[] >
	{
		static final Convert_f32_to_u16 INSTANCE = new Convert_f32_to_u16();

		@Override
		public void apply( final float[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_i32 implements ConvertLoop< float[], int[] >
	{
		static final Convert_f32_to_i32 INSTANCE = new Convert_f32_to_i32();

		@Override
		public void apply( final float[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_u32 implements ConvertLoop< float[], int[] >
	{
		static final Convert_f32_to_u32 INSTANCE = new Convert_f32_to_u32();

		@Override
		public void apply( final float[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_i64 implements ConvertLoop< float[], long[] >
	{
		static final Convert_f32_to_i64 INSTANCE = new Convert_f32_to_i64();

		@Override
		public void apply( final float[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_f32 implements ConvertLoop< float[], float[] >
	{
		static final Convert_f32_to_f32 INSTANCE = new Convert_f32_to_f32();

		@Override
		public void apply( final float[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f32_to_f64 implements ConvertLoop< float[], double[] >
	{
		static final Convert_f32_to_f64 INSTANCE = new Convert_f32_to_f64();

		@Override
		public void apply( final float[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_f32( src[ i ] ) );
		}
	}

	static class Convert_f64_to_i8 implements ConvertLoop< double[], byte[] >
	{
		static final Convert_f64_to_i8 INSTANCE = new Convert_f64_to_i8();

		@Override
		public void apply( final double[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i8( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_u8 implements ConvertLoop< double[], byte[] >
	{
		static final Convert_f64_to_u8 INSTANCE = new Convert_f64_to_u8();

		@Override
		public void apply( final double[] src, final byte[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u8( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_i16 implements ConvertLoop< double[], short[] >
	{
		static final Convert_f64_to_i16 INSTANCE = new Convert_f64_to_i16();

		@Override
		public void apply( final double[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i16( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_u16 implements ConvertLoop< double[], short[] >
	{
		static final Convert_f64_to_u16 INSTANCE = new Convert_f64_to_u16();

		@Override
		public void apply( final double[] src, final short[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u16( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_i32 implements ConvertLoop< double[], int[] >
	{
		static final Convert_f64_to_i32 INSTANCE = new Convert_f64_to_i32();

		@Override
		public void apply( final double[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i32( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_u32 implements ConvertLoop< double[], int[] >
	{
		static final Convert_f64_to_u32 INSTANCE = new Convert_f64_to_u32();

		@Override
		public void apply( final double[] src, final int[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_u32( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_i64 implements ConvertLoop< double[], long[] >
	{
		static final Convert_f64_to_i64 INSTANCE = new Convert_f64_to_i64();

		@Override
		public void apply( final double[] src, final long[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_i64( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_f32 implements ConvertLoop< double[], float[] >
	{
		static final Convert_f64_to_f32 INSTANCE = new Convert_f64_to_f32();

		@Override
		public void apply( final double[] src, final float[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f32( from_f64( src[ i ] ) );
		}
	}

	static class Convert_f64_to_f64 implements ConvertLoop< double[], double[] >
	{
		static final Convert_f64_to_f64 INSTANCE = new Convert_f64_to_f64();

		@Override
		public void apply( final double[] src, final double[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_f64( from_f64( src[ i ] ) );
		}
	}
}
