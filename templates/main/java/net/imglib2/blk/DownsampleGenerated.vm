/*
 * TODO: imglib2 header
 */

/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package net.imglib2.blk.downsample;

/**
 * @author Tobias Pietzsch
 */
public class DownsampleGenerated
{
#set($primitive = {
    "u8" : "byte",
    "i8" : "byte",
    "u16" : "short",
    "i16" : "short",
    "u32" : "int",
    "i32" : "int",
    "u64" : "long",
    "i64" : "long",
    "f32" : "float",
    "f64" : "double"
} )
#set($integral = {
    "u8" : true,
    "i8" : true,
    "u16" : true,
    "i16" : true,
    "u32" : true,
    "i32" : true,
    "u64" : true,
    "i64" : true,
    "f32" : false,
    "f64" : false
} )
#set($iotypes = [
    ["f64", "u8"],
    ["u8", "f64"],
    ["f64", "f64"],
    ["u8", "u8"]
] )

#foreach($prim1 in $primitive.keySet())
    #foreach($prim2 in $primitive.keySet())
        ${prim1}-${prim2}
    #end
#end



#foreach($iotype in $iotypes)
    #set( $inP = $primitive[$iotype[0]] )
    #set( $outP = $primitive[$iotype[1]] )
    #set( $inPA = "${inP}[]" )
    #set( $outPA = "${outP}[]" )
    #set( $suffix = "${iotype[0]}_${iotype[1]}")

    private static void downsample_$suffix( final $inPA source, final int[] destSize, final $outPA dest, final int dim )
    {
        if ( dim == 0 )
            downsampleX_$suffix( source, destSize, dest );
        else
            downsampleN_$suffix( source, destSize, dest, dim );
    }

    private static void downsampleX_$suffix( final $inPA source, final int[] destSize, final $outPA dest )
    {
        final int len1 = destSize[ 0 ];
        final int len2 = mulDims( destSize, 1, destSize.length );
        for ( int z = 0; z < len2; ++z )
        {
            final int destOffsetZ = z * len1;
            final int srcOffsetZ = z * ( 2 * len1 + 1 );
            for ( int x = 0; x < len1; ++x )
            {
                dest[ destOffsetZ + x ] = wavg_$suffix(
                        source[ srcOffsetZ + 2 * x ],
                        source[ srcOffsetZ + 2 * x + 1 ],
                        source[ srcOffsetZ + 2 * x + 2 ] );
            }
        }
    }

    private static void downsampleN_$suffix( final $inPA source, final int[] destSize, final $outPA dest, final int dim )
    {
        final int len0 = mulDims( destSize, 0, dim );
        final int len1 = destSize[ dim ];
        final int len2 = mulDims( destSize, dim + 1, destSize.length );
        for ( int z = 0; z < len2; ++z )
        {
            final int destOffsetZ = z * len1 * len0;
            final int srcOffsetZ = z * ( 2 * len1 + 1 ) * len0;
            for ( int y = 0; y < len1; ++y )
            {
                final int destOffset = destOffsetZ + y * len0;
                final int srcOffset = srcOffsetZ + 2 * y * len0;
                for ( int x = 0; x < len0; ++x )
                {
                    dest[ destOffset + x ] = wavg_$suffix(
                            source[ srcOffset + x ],
                            source[ srcOffset + x + len0 ],
                            source[ srcOffset + x + 2 * len0 ] );
                }
            }
        }
    }

    #end

	// -- helpers --

	private static int mulDims( int[] dims, int from, int to )
	{
		int product = 1;
		for ( int d = from; d < to; ++d )
			product *= dims[ d ];
		return product;
	}

}