/*
 * TODO: imglib2 header
 */

/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package net.imglib2.blk.downsample;

import net.imglib2.type.NativeType;
import net.imglib2.util.Cast;

## pixel types
## (u64 is not included for now)
#set( $types = ["i8", "u8", "i16", "u16", "i32", "u32", "i64", "f32", "f64"] )

## maps pixel type to Java primitive type used for storage
#set( $storage_primitive = {
    "i8" : "byte",
    "u8" : "byte",
    "i16" : "short",
    "u16" : "short",
    "i32" : "int",
    "u32" : "int",
    "i64" : "long",
    "u64" : "long",
    "f32" : "float",
    "f64" : "double"
} )

## maps pixel type to Java primitive type used for computation
#set( $compute_primitive = {
    "i8" : "int",
    "u8" : "int",
    "i16" : "int",
    "u16" : "int",
    "i32" : "int",
    "u32" : "long",
    "i64" : "long",
    "f32" : "float",
    "f64" : "double"
} )

## unsigned integral types have masks to convert them to signed
#set( $mask = {
    "u8" : "0xff",
    "u16" : "0xffff",
    "u32" : "0xffffffffL"
} )

#set( $max_value = {
    "i8" : "0x7f",
    "u8" : "0xff",
    "i16" : "0x7fff",
    "u16" : "0xffff",
    "i32" : "0x7fff_ffff",
    "u32" : "0xffff_ffffL"
} )

#set( $min_value = {
    "i8" : "-0x80",
    "u8" : "0",
    "i16" : "-0x8000",
    "u16" : "0",
    "i32" : "-0x8000_0000",
    "u32" : "0L"
} )

## whether a pixel type is integral
#set( $is_integral = {
    "i8" : true,
    "u8" : true,
    "i16" : true,
    "u16" : true,
    "i32" : true,
    "u32" : true,
    "i64" : true,
    "u64" : true,
    "f32" : false,
    "f64" : false
} )

## number of bits in Java primitive type
#set( $nbits = {
    "byte" : 8,
    "short" : 16,
    "int" : 32,
    "long" : 64,
    "float" : 32,
    "double" : 64
} )


class TypeConversionGenerated
{

##
## from_i8(), etc., with corresponding compute_primitive as result type
##
#foreach( $t in $types )
#set( $cp = $compute_primitive[$t] )
#set( $sp = $storage_primitive[$t] )
#set( $m = $mask[$t] )
	static $cp from_$t( $sp value ) { return value#if( $m ) & $m#end; }
#end

##
## to_i8(), etc., for int/long
##
#foreach( $cp in ["int", "long"] )
#foreach( $t in $types )
#set( $sp = $storage_primitive[$t] )
#set( $max = $max_value[$t] )
#set( $min = $min_value[$t] )
#if( $nbits[$sp] >= $nbits[$cp] )
    static $sp to_${t}( $cp value ) { return value; }
#else
    static $sp to_${t}( $cp value ) { return ( $sp ) value; }
#end
#if( $max && !( $cp=="int" && $t=="i32" ) )
    static $sp to_${t}_clamp_max( $cp value ) { return to_${t}( Math.min( $max, value ) ); }
    static $sp to_${t}_clamp( $cp value ) { return to_${t}( Math.min( $max, Math.max( $min, value ) ) ); }
#else
    static $sp to_${t}_clamp_max( $cp value ) { return to_${t}( value ); }
    static $sp to_${t}_clamp( $cp value ) { return to_${t}( value ); }
#end
#end

#end
##
## to_i8(), etc., for float/double
## rounds and forward to int/long variants
##
#foreach( $cp in ["float", "double"] )
#foreach( $t in $types )
#set( $sp = $storage_primitive[$t] )
#set( $double_rounding = ["u32", "i64"] )
#if( $cp.equals("float") && $double_rounding.contains($t) )
	static $sp to_${t}( $cp value ) { return to_${t}( Math.round( ( double ) value ) ); }
	static $sp to_${t}_clamp_max( $cp value ) { return to_${t}_clamp_max( Math.round( ( double ) value ) ); }
	static $sp to_${t}_clamp( $cp value ) { return to_${t}_clamp( Math.round( ( double ) value ) ); }
#else
    static $sp to_${t}( $cp value ) { return to_${t}( Math.round( value ) ); }
	static $sp to_${t}_clamp_max( $cp value ) { return to_${t}_clamp_max( Math.round( value ) ); }
	static $sp to_${t}_clamp( $cp value ) { return to_${t}_clamp( Math.round( value ) ); }
#end
#end

#end



## TODO: for later ...
## probably go via enum
#set( $to_imglib2 = {
    "i8"  : "ByteType",
    "u8"  : "UnsignedByteType",
    "i16" : "ShortType",
    "u16" : "UnsignedShortType",
    "i32" : "IntType",
    "u32" : "UnsignedIntType",
    "i64" : "LongType",
    "u64" : "UnsignedLongType",
    "f32" : "FloatType",
    "f64" : "DoubleType"
} )
#set( $from_imglib2 = {
    "ByteType"          : "i8",
    "UnsignedByteType"  : "u8",
    "ShortType"         : "i16",
    "UnsignedShortType" : "u16",
    "IntType"           : "i32",
    "UnsignedIntType"   : "u32",
    "LongType"          : "i64",
    "UnsignedLongType"  : "u64",
    "FloatType"         : "f32",
    "DoubleType"        : "f64"
} )

enum UnaryOperatorType
{
#foreach( $t1 in $types )
    #foreach( $t2 in $types )${t1.toUpperCase()}_TO_${t2.toUpperCase()}, #end

#end
    ;

	static UnaryOperatorType of( NativeType< ? > source, NativeType<?> target )
	{
		return of( OperandType.of( source ), OperandType.of( target ) );
	}

	static UnaryOperatorType of( OperandType source, OperandType target )
	{
		switch ( source )
		{
#foreach( $t1 in $types )
        case ${t1.toUpperCase()}:
            switch ( target)
            {
#foreach( $t2 in $types )
            case ${t2.toUpperCase()}:
				return ${t1.toUpperCase()}_TO_${t2.toUpperCase()};
#end
			default:
				throw new IllegalArgumentException();
			}
#end
		default:
			throw new IllegalArgumentException();
        }
	}
}



    @FunctionalInterface
    interface ConvertLoop< I, O >
    {
        void apply( final I src, final O dest, final int length );

        static < I, O > ConvertLoop< I, O > get( UnaryOperatorType type )
        {
            switch( type )
            {
#foreach( $t1 in $types )
#foreach( $t2 in $types )
            case ${t1.toUpperCase()}_TO_${t2.toUpperCase()}:
				return Cast.unchecked( Convert_${t1}_to_${t2}.INSTANCE );
#end
#end
            default:
                throw new IllegalArgumentException();
            }
        }
    }

#foreach( $t1 in $types )
#set( $sp1 = $storage_primitive[$t1] )
#foreach( $t2 in $types )
#set( $sp2 = $storage_primitive[$t2] )

	static class Convert_${t1}_to_${t2} implements ConvertLoop< ${sp1}[], ${sp2}[] >
	{
		static final Convert_${t1}_to_${t2} INSTANCE = new Convert_${t1}_to_${t2}();

		@Override
		public void apply( final ${sp1}[] src, final ${sp2}[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_$t2( from_$t1( src[ i ] ) );
		}
	}
#end
#end
}
