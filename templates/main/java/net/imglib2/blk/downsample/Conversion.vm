/*
 * TODO: imglib2 header
 */

/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package net.imglib2.blk.downsample;

import net.imglib2.type.NativeType;
import net.imglib2.util.Cast;

#parse( "PixelTypes.vm" )
class TypeConversionGenerated
{

##
## from_i8(), etc., with corresponding compute_primitive as result type
##
    /*
     * Methods to convert each pixel type (i8, u8, i16, u16, i32, u32, i64, f32, f64)
     * to the corresponding primitive type used for computation.
     *
     * i8, u8, i16, u16, i32 are all converted to int, because java
     * computes in int for byte, short, and int operands.
     *
     * u32, i64 are converted to long, because that is the primitive type that
     * can represent all values of the pixel type.
     *
     * f32 is converted to float
     *
     * f64 is converted to double
     */
#foreach( $t in $types )
#set( $cp = $compute_primitive[$t] )
#set( $sp = $storage_primitive[$t] )
#set( $m = $mask[$t] )
	static $cp from_$t( $sp value ) { return value#if( $m ) & $m#end; }
#end

##
## to_i8(), etc., for int/long
##
#foreach( $cp in ["int", "long"] )
#foreach( $t in $types )
#set( $sp = $storage_primitive[$t] )
#set( $max = $max_value[$t] )
#set( $min = $min_value[$t] )
#if( $nbits[$sp] >= $nbits[$cp] )
    static $sp to_${t}( $cp value ) { return value; }
#else
    static $sp to_${t}( $cp value ) { return ( $sp ) value; }
#end
#if( $max && !( $cp=="int" && $t=="i32" ) )
    static $sp to_${t}_clamp_max( $cp value ) { return to_${t}( Math.min( $max, value ) ); }
    static $sp to_${t}_clamp( $cp value ) { return to_${t}( Math.min( $max, Math.max( $min, value ) ) ); }
#else
    static $sp to_${t}_clamp_max( $cp value ) { return to_${t}( value ); }
    static $sp to_${t}_clamp( $cp value ) { return to_${t}( value ); }
#end
#end

#end
##
## to_i8(), etc., for float/double
## rounds and forward to int/long variants
##
#foreach( $cp in ["float", "double"] )
#foreach( $t in $types )
#set( $sp = $storage_primitive[$t] )
#set( $double_rounding = ["u32", "i64"] )
#if( $cp.equals("float") && $double_rounding.contains($t) )
	static $sp to_${t}( $cp value ) { return to_${t}( Math.round( ( double ) value ) ); }
	static $sp to_${t}_clamp_max( $cp value ) { return to_${t}_clamp_max( Math.round( ( double ) value ) ); }
	static $sp to_${t}_clamp( $cp value ) { return to_${t}_clamp( Math.round( ( double ) value ) ); }
#else
    static $sp to_${t}( $cp value ) { return to_${t}( Math.round( value ) ); }
	static $sp to_${t}_clamp_max( $cp value ) { return to_${t}_clamp_max( Math.round( value ) ); }
	static $sp to_${t}_clamp( $cp value ) { return to_${t}_clamp( Math.round( value ) ); }
#end
#end

#end



## TODO: for later ...
## probably go via enum
#set( $to_imglib2 = {
    "i8"  : "ByteType",
    "u8"  : "UnsignedByteType",
    "i16" : "ShortType",
    "u16" : "UnsignedShortType",
    "i32" : "IntType",
    "u32" : "UnsignedIntType",
    "i64" : "LongType",
    "u64" : "UnsignedLongType",
    "f32" : "FloatType",
    "f64" : "DoubleType"
} )
#set( $from_imglib2 = {
    "ByteType"          : "i8",
    "UnsignedByteType"  : "u8",
    "ShortType"         : "i16",
    "UnsignedShortType" : "u16",
    "IntType"           : "i32",
    "UnsignedIntType"   : "u32",
    "LongType"          : "i64",
    "UnsignedLongType"  : "u64",
    "FloatType"         : "f32",
    "DoubleType"        : "f64"
} )

    @FunctionalInterface
    interface ConvertLoop< I, O >
    {
        void apply( final I src, final O dest, final int length );

        static < I, O > ConvertLoop< I, O > get( UnaryOperatorType type )
        {
            switch( type )
            {
#foreach( $t1 in $types )
#foreach( $t2 in $types )
            case ${t1.toUpperCase()}_TO_${t2.toUpperCase()}:
				return Cast.unchecked( Convert_${t1}_to_${t2}.INSTANCE );
#end
#end
            default:
                throw new IllegalArgumentException();
            }
        }
    }

#foreach( $t1 in $types )
#set( $sp1 = $storage_primitive[$t1] )
#foreach( $t2 in $types )
#set( $sp2 = $storage_primitive[$t2] )

	static class Convert_${t1}_to_${t2} implements ConvertLoop< ${sp1}[], ${sp2}[] >
	{
		static final Convert_${t1}_to_${t2} INSTANCE = new Convert_${t1}_to_${t2}();

		@Override
		public void apply( final ${sp1}[] src, final ${sp2}[] dest, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ i ] = to_$t2( from_$t1( src[ i ] ) );
		}
	}
#end
#end
}
